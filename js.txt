                                             "Js"

----------------------------------------------------------------------------------------------------------------------
                                        Part 1 to 5 : "Learn Js Foundation"
----------------------------------------------------------------------------------------------------------------------


Parsing: Now parsing is reading the code file and then storing the keywords like console,for,class and then understand
         what user wants.


    [Before the code run-time]     
               |
 {[code file]->parse->[syntax tree]}--->{[JIT(just in time)Conpiler]}--->{First it[byte code]->[machine code]}--->[Code Execution]  
  
   This is the execition cycle of the javascript code 
 
 Kaywords in above diagram:
 JIT compiler  first change the code in just byte code file and then compiler convert it into Machine code.


 Type of DataTypes:

 So there are basically 2 types:
    - Primitive   - String, Boolean, Number, null, undefined ,Symbol
    - Non Primitive - Object, Array, function 


    The array method Slice() :  is correct because it creates a shallow copy of a s
    pecified portion of an array without modifying the original array, aligning perfectly with the 
    question's requirement. This makes it a fundamental tool for working with arrays in programming, 
    reinforcing your understanding of array manipulation.

--------------------------------------------------------------------------------------------------------------------
                                                 INTRODUCTION TO lOOPS:

All done within the files.

--------------------------------------------------------------------------------------------------------------
                                                  Function in Js :-
  
Now people say that arrow funtiion do not have "this" reference .

function fun (){
  console.log(this);
}
fun();
//This when runned on a browser console will give a something like windows object which mean that it gives a reference of browser .

//Same when arrow funtion is called on browser console also give same reference which mean that arrow fuction also have this reference//


===============================================================================================

Now                                    Higher order function / First class function

A function which take a function as a paramerter is called higher class/order function.

The best example for this is : forEach loop.

arrTeas.forEach((tea)=> {
          if(tea === "chai" || tea === "Chai"){
             return;
          }
          // Here you can check that a object arrTeas is calling a forEach function which has argument as a arrow function

-----------------------------------------------------------------------------------------------------------------

                                         Nesting of function:

function createTeaMaker (){
          return function (teaType){
               return `Making ${teaType}`
          }
   }
   let teaMaker = createTeaMaker(); // above as we are returning a funciton so this teaMaker has instance of that function so we can call that fucntion 
                                     // with help of teaMaker ex: teaMaker() this will envoke the function which is inside that createTeaMaker . Which is also returned by createTeaMaker.
   let printThisValue = teaMaker("Green sharbat")
   
   console.log(printThisValue); // Making Green Sharbat

  Now lets check wheather we can access the paramerter of parent funtion in inside function. ------------------------------------------------

  function createTeaMaker (name , order){
          return function (teaType){
               return `Making ${teaType} for ${name}. The order Number is ${order}` // Here this is example that inner function is accesing the parameter of parent function.
          }
   }
   let teaMaker = createTeaMaker("Sahil" , 33); // above as we are returning a funciton so this teaMaker has instance of that function so we can call that fucntion 
                                     // with help of teaMaker ex: teaMaker() this will envoke the function which is inside that createTeaMaker . Which is also returned by createTeaMaker.
   let printThisValue = teaMaker("Green sharbat")
  
   console.log(printThisValue);  // Output : Making Green Sharbat for Sahil. The order number is 33

=====================================================================================================================================
                // Array.prototype.map() :-

The map() method creates a new array populated with the results of calling a provided function on every element in the calling array. 
The key benefits are:
Transformation: It transforms each element from the original array.

Immutability: It doesn't change the original array; instead, it returns a new array with transformed values.
Parameters

callbackFn:-

A function to execute for each element in the array. Its return value is added as a single element in the new array. 
The function is called with the following arguments:

element
The current element being processed in the array.

index
The index of the current element being processed in the array.

array
The array map() was called upon.

thisArg Optional
A value to use as this when executing callbackFn. See iterative methods.

Return value
A new array with each element being the result of the callback function.

----------------------------------------------------------------------------------------------------------------------
                                                    Part6 (Javascript OOps)
----------------------------------------------------------------------------------------------------------------------
 
 JavaScript prototypes are like the behind-the-scenes wizards that enable powerful inheritance and 
 object behavior.

 function Animal(name) {
   this.name = name;
  }

    Animal.prototype.speak = function() {
    console.log(`${this.name} makes a noise.`);
  };

  const dog = new Animal('Buddy');
  dog.speak(); // Buddy makes a noise.
 

 /*
                                " Prof that js is prototype based."
let myArr = [1,2,3,4,5]
undefined
myArr
(5) [1, 2, 3, 4, 5]
0: 1
1: 2
2: 3
3: 4
4: 5
length: 5
[[Prototype]]: Array(0)
When we further click on this prototype the further functinality available for array will appear

[[Prototype]]: Array(0)
at: ƒ at()
concat : ƒ concat()
constructor : ƒ Array()
copyWithin : ƒ copyWithin()
entries : ƒ entries()
every : ƒ every()
fill : ƒ fill()
filter : ƒ filter()
find : ƒ find()
findIndex : ƒ findIndex()
findLast : ƒ findLast()
findLastIndex : ƒ findLastIndex()
flat : ƒ flat()
flatMap : ƒ flatMap()
forEach : ƒ forEach()
includes : ƒ includes()
indexOf : ƒ indexOf()
join : ƒ join()
keys : ƒ keys()
lastIndexOf : ƒ lastIndexOf()
length : 0
map: ƒ map()
pop : ƒ pop()
push : ƒ push()
reduce : ƒ reduce()
reduceRight : ƒ reduceRight()
reverse : ƒ reverse()
shift : ƒ shift()
slice : ƒ slice()
some : ƒ some()
sort : ƒ sort()
splice : ƒ splice()
toLocaleString : ƒ toLocaleString()
toReversed : ƒ toReversed()
toSorted : ƒ toSorted()
toSpliced : ƒ toSpliced()
toString : ƒ toString()
unshift : ƒ unshift()
values : ƒ values()
with : ƒ with()
Symbol( Symbol.iterator) : ƒ values()
Symbol(Symbol.unscopables): {at: true, copyWithin: true, entries: true, fill: true, find: true, …}
[[Prototype]] : Object ﻿
Further for oject we can check the functionality .
This is the prof that js use prototype.

                                      "Just read this is "PROTOTYPE" will be clear to you"
What Is a Prototype in JavaScript?
Every object in JavaScript has a hidden property called [[Prototype]] (commonly accessed as __proto__). This property points to another object, and that object is its prototype.
Think of it like a chain of knowledge:
If an object doesn’t know how to do something, it asks its prototype. If that prototype doesn’t know, it goes up its prototype chain—and so on—until it hits the end, which is null.

Why Is It Useful?
This system is what enables inheritance in JavaScript without classes (before ES6). It allows you to define properties and methods in one place and have many objects share that behavior.

Code Example
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  return `${this.name} makes a noise.`;
};

const dog = new Animal("Doggo");
console.log(dog.speak()); // "Doggo makes a noise."


Here:
- dog is an instance of Animal
- It doesn’t have a speak() method directly
- But dog.__proto__ === Animal.prototype, so JS finds speak up the chain

Bonus: Prototype vs. __proto__ vs. Object.getPrototypeOf
- .prototype: Exists on constructor functions (like Animal)—used when creating new objects.
- __proto__: Actual internal link from one object to its prototype. Mostly for debugging.
- Object.getPrototypeOf(obj): Preferred and safe way to access the prototype.

*/ 

-----------------------------------------------------------------------------------------------------------------

                              "51.Functional constructor and Errors:- "

Previously as we studied that we can make a blueprint with the help of "class" however in js there is another
way and that is "constructor function" . Also as we have studied we can reuse the code written in function and similarly
a class can have multiple objecs and single blueprint can be used many places.


function Person ( name, age) {
   //let myName = name ; // Now initialy we are only using the parameter value now we want to save it in a variable.
    // Now this above one is also a valid way however in construtor functon we use it like this.name = name.
    //** Also when we intialize a new varible then we also have to return it as it act as a funtion in that case. 
    this.name = name;   // when using this.name then it act as a constructor function. 
    this.age = age; 
}
//now this new keyword is conecte to this keyword so it can access the value without returning it.
let myCafe  = new Person("Sahil" , 33); Now this is using it as a constructor fuction as we are using new keywod.
console.log(myCafe) ; Output : Peron {name : 'Sahil' , age : 33}

// *** Now lets check this and lets not use the this.name in the defination and make it a simple fuction.
fucntion Person1 (name , age){
    let myName = name;
    let myAge = age;   // as this a normal funciton we can not acces it values directly so we have to return this and then catch it.
}
    
                                         Contructor fucntion VS Prototype.